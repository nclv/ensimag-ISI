[`GROUP BY` vs `DISTINCT`](https://stackoverflow.com/questions/581521/whats-faster-select-distinct-or-group-by-in-mysql)

Les [jointures](https://sql.sh/cours/jointures)

List all tables on http://adminer.ensimag.fr.
```sql
SELECT * FROM all_tables WHERE TABLESPACE_NAME='USERS';
```

## TD Hotels.
```sql
-- Q3
SELECT DISTINCT NomS FROM RESORTS NATURAL JOIN HOTELS WHERE TypeS='mer' AND CatH='4'; 

-- Q4
SELECT DISTINCT NomCl, AdrCl FROM GUESTS NATURAL JOIN BOOKINGS NATURAL JOIN RESORTS WHERE TypeS='montagne';
SELECT DISTINCT NomCl, AdrCl FROM GUESTS, BOOKINGS, RESORTS WHERE Guests.NCL = Bookings.NCL AND Bookings.NS = Resorts.NS AND Resorts.TypeS='montagne';

-- Q5
SELECT NCH, Hotels.NH, Rooms.NS FROM ROOMS, HOTELS, RESORTS
WHERE Rooms.NS = Hotels.NS AND Hotels.NH = Rooms.NH AND Resorts.NS = Hotels.NS
AND Resorts.TypeS = 'montagne' AND Hotels.CatH = '2' AND Rooms.Prix < 50;

-- Q8
SELECT h.ns, h.nh, h.nomh from hotels h, rooms ro where cath=4 and ro.ns = h.ns and ro.nh = h.nh group by h.ns, h.nh, h.nomh having min(ro.typch) = 'SDB';

SELECT distinct h.ns, h.nh, h.nomh 
from hotels h, rooms ro 
where catH = 4 
and ro.ns = h.ns and ro.nh = h.nh 
and ro.typch = all
(select typch from rooms where typch = 'SDB');

-- Q9

```

## TP EMP

```sql
-- Q1
select empno, ename from emp

-- Q2
select empno, ename, hiredate from emp where deptno = 20

-- Q3
select sum(sal) from emp

-- Q4
select empno, ename, job, sal from emp where job = 'MANAGER' and sal > 2800

-- Q5
select empno, ename from emp join dept on emp.deptno = dept.deptno where loc = 'DALLAS'

-- Q6
select empno, ename, job, sal from emp where deptno = 30 order by sal ASC

-- Q7
select distinct job from emp

-- Q8
select empno, ename from emp where ename like 'M%' and sal >= 1290

-- Q9
select emp.deptno, loc from emp join dept on emp.deptno = dept.deptno where ename = 'ALLEN'

-- Q10
select distinct emp.deptno, dname from emp join dept on emp.deptno = dept.deptno where job in ('CLERK', 'SALESMAN', 'ANALYST')

-- Q11
select distinct t2.empno, t2.ename from emp t1 join emp t2 on t1.mgr = t2.empno where t1.comm is not NULL and t2.job = 'MANAGER'

-- Q12
select empno, ename from emp join dept on emp.deptno = dept.deptno where loc in ('DALLAS', 'CHICAGO') and sal > 1000

-- Q13
select dept.deptno, dname, job, sum(sal), count(empno), avg(sal) from dept join emp on emp.deptno = dept.deptno group by dept.deptno, dname, job having count(empno) > 2

-- Q14
select emp.empno, ename, sal, grade, mgr, emp.deptno, dname from salgrade, emp join dept on dept.deptno = emp.deptno where sal between losal and hisal

-- Q15
select emp.deptno, dname, cast(avg(sal) as decimal(6, 2)) from emp join dept on emp.deptno = dept.deptno group by emp.deptno, dname -- il manque une entrée, le cas avg NULL

select dept.deptno, dname, cast(avg(sal) as decimal(6, 2)) from dept full join emp on emp.deptno = dept.deptno group by dept.deptno, dname -- c'est corrigé avec full join

-- Q16
with sal_total as (select sum(sal) as sal_total from emp), comm_total as (select sum(comm) as comm_total from emp)
select empno, ename, cast(sal / sal_total.sal_total * 100 as decimal(6, 2)) as sal_percent, cast(comm / comm_total.comm_total * 100 as decimal(6, 2)) as comm_percent from emp, sal_total, comm_total

-- Q17
select deptno, total from (select deptno, sum(sal) as total, row_number() over (order by sum(sal) desc) as rn, count(*) over () as total_count from emp group by deptno)
where rn = 1 or rn = total_count
order by deptno desc
-- count(*) over () renvoie le résultat de count(*) dans une nouvelle colonne pour toutes les entrées et pas seulement le résultat de count(*)
-- DEPTNO	TOTAL	RN	TOTAL_COUNT
-- 30	9400	1	3
-- 20	6775	3	3
-- 10	8750	2	3

-- Q18
select dept.deptno, dept.loc from emp join dept on emp.deptno = dept.deptno where loc not in ('CHICAGO') group by dept.deptno, dept.loc having count(empno) >= 3

-- Q19
select dept.deptno from emp full join dept on emp.deptno = dept.deptno group by dept.deptno having count(empno) = 0
-- ou
select dept.deptno from emp full join dept on emp.deptno = dept.deptno where emp.deptno is NULL

-- Q20
select deptno from (select dept.deptno, count(empno) as emp_count from emp join dept on emp.deptno = dept.deptno group by dept.deptno) group by deptno order by max(emp_count) desc fetch first 1 rows only
-- remplacer fetch first par min ou max
```

## TD Transactions

Dans Oracle on est toujours dans une transaction.

```bash
sudo openconnect vpn.grenet.fr
ssh vincentn@pcserveur.ensimag.fr
sqlplus <login>@oracle1
```

```sql
CREATE TABLE Comptes(
    NC NUMBER GENERATED BY DEFAULT AS IDENTITY,
    nom VARCHAR2(10) NOT NULL,
    solde INT CHECK(solde >= 0),
    PRIMARY KEY(NC)
);

-- Partie 1: atomicité
-- Exercice 1
insert into comptes values (4567, 'Paul', 10000);
insert into comptes values (4568, 'Paul', 30000);

select sum(solde) from comptes;

rollback;
-- plus aucune entrée dans la table

-- Exercice 2
insert into comptes values (4568, 'Pierre', 4000);
insert into comptes values (4569, 'Pierre', 200);
commit;

insert into comptes values (4567, 'Paul', 10000);
insert into comptes values (4570, 'Paul', 30000);

select nom, sum(solde) from comptes group by nom;

rollback;

-- Exercice 3
set autocommit on;
-- same as before

-- Exercice 4
insert into comptes values (4580, 'Jacques', 800);
insert into comptes values (4581, 'Jacques', 4000);
savepoint DeuxInserts;

select sum(solde) from comptes where nom = 'Jean';

rollback to DeuxInserts;

-- Partie 2: cohérence
-- Exercice 1
insert into comptes values (4345, 'Claude', 100);
insert into comptes values (4235, 'Henry', 200);
update comptes set solde = solde + 50 where nom = 'Claude';
update comptes set solde = solde - 150 where nom = 'Henry';

select * from comptes;

rollback;

-- Partie 3: Isolation
-- Exercice 1
delete from comptes where nom = 'Jacques';

-- en attente pour update

-- Exercice 2
select sum(solde) from comptes;
set transaction isolation level serializable;
-- la machine en level serializable n'est pas influencée par les autres machines

-- Exercice 3

```
